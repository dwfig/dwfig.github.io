
(function(l, r) { if (l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (window.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(window.document);
import { onMount, Knob, Patch } from '/js/core.js';

/* ../core/src/components/Faceplate.svelte generated by Svelte v3.31.2 */


function add_css() {
	var style = __sv.element("style");
	style.id = "svelte-1ugmpjz-style";
	style.textContent = "div.svelte-1ugmpjz{display:block;width:100%;height:100%;position:relative}h1.svelte-1ugmpjz,svg.svelte-1ugmpjz{pointer-events:none}h1.svelte-1ugmpjz{font-family:'Routed Gothic Wide';font-size:14px;line-height:14px;position:absolute;text-align:center;top:24px;width:100%}svg.svelte-1ugmpjz{position:absolute;opacity:0.4}.screw-1.svelte-1ugmpjz,.screw-2.svelte-1ugmpjz{top:2px}.screw-3.svelte-1ugmpjz,.screw-4.svelte-1ugmpjz{bottom:3px}.screw-1.svelte-1ugmpjz,.screw-3.svelte-1ugmpjz{left:2px}.screw-2.svelte-1ugmpjz,.screw-4.svelte-1ugmpjz{right:2px}";
	__sv.append(document.head, style);
}

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[6] = list[i];
	return child_ctx;
}

// (57:2) {#if title}
function create_if_block(ctx) {
	let h1;
	let t;

	return {
		c() {
			h1 = __sv.element("h1");
			t = __sv.text(/*title*/ ctx[0]);
			__sv.attr(h1, "class", "svelte-1ugmpjz");
		},
		m(target, anchor) {
			__sv.insert(target, h1, anchor);
			__sv.append(h1, t);
		},
		p(ctx, dirty) {
			if (dirty & /*title*/ 1) __sv.set_data(t, /*title*/ ctx[0]);
		},
		d(detaching) {
			if (detaching) __sv.detach(h1);
		}
	};
}

// (61:2) {#each [1, 2, 3, 4] as index}
function create_each_block(ctx) {
	let svg;
	let path;

	return {
		c() {
			svg = __sv.svg_element("svg");
			path = __sv.svg_element("path");
			__sv.attr(path, "d", "M6 12A6 6 0 106 0a6 6 0 000 12zm5-6A5 5 0 111 6a5 5 0 0110 0zM4 4.667L4.667 4 6 5.333 7.333 4 8 4.667 6.667 6\n\t\t\t\t8 7.333 7.333 8 6 6.667 4.667 8 4 7.333 5.333 6 4 4.667z");
			__sv.attr(path, "fill", "currentColor");
			__sv.attr(svg, "class", "" + (__sv.null_to_empty(`screw-${/*index*/ ctx[6]}`) + " svelte-1ugmpjz"));
			__sv.attr(svg, "width", "12");
			__sv.attr(svg, "height", "12");
			__sv.attr(svg, "fill", "none");
			__sv.attr(svg, "xmlns", "http://www.w3.org/2000/svg");
		},
		m(target, anchor) {
			__sv.insert(target, svg, anchor);
			__sv.append(svg, path);
		},
		d(detaching) {
			if (detaching) __sv.detach(svg);
		}
	};
}

function create_fragment(ctx) {
	let div;
	let t0;
	let t1;
	let current;
	let if_block = /*title*/ ctx[0] && create_if_block(ctx);
	const default_slot_template = /*#slots*/ ctx[5].default;
	const default_slot = __sv.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);
	let each_value = [1, 2, 3, 4];
	let each_blocks = [];

	for (let i = 0; i < 4; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	return {
		c() {
			div = __sv.element("div");
			if (if_block) if_block.c();
			t0 = __sv.space();
			if (default_slot) default_slot.c();
			t1 = __sv.space();

			for (let i = 0; i < 4; i += 1) {
				each_blocks[i].c();
			}

			__sv.attr(div, "draggable", "");
			__sv.set_style(div, "background-repeat", "no-repeat");
			__sv.set_style(div, "background-color", /*color*/ ctx[1]);
			__sv.set_style(div, "background-image", (/*image*/ ctx[3] ? `url('${/*image*/ ctx[3]}')` : `none`) + " ");
			__sv.set_style(div, "color", "var(--color-" + (/*light*/ ctx[2] ? "dark" : "light") + ")");
			__sv.attr(div, "class", "svelte-1ugmpjz");
		},
		m(target, anchor) {
			__sv.insert(target, div, anchor);
			if (if_block) if_block.m(div, null);
			__sv.append(div, t0);

			if (default_slot) {
				default_slot.m(div, null);
			}

			__sv.append(div, t1);

			for (let i = 0; i < 4; i += 1) {
				each_blocks[i].m(div, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (/*title*/ ctx[0]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					if_block.m(div, t0);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 16) {
					__sv.update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[4], dirty, null, null);
				}
			}

			if (!current || dirty & /*color*/ 2) {
				__sv.set_style(div, "background-color", /*color*/ ctx[1]);
			}

			if (!current || dirty & /*image*/ 8) {
				__sv.set_style(div, "background-image", (/*image*/ ctx[3] ? `url('${/*image*/ ctx[3]}')` : `none`) + " ");
			}

			if (!current || dirty & /*light*/ 4) {
				__sv.set_style(div, "color", "var(--color-" + (/*light*/ ctx[2] ? "dark" : "light") + ")");
			}
		},
		i(local) {
			if (current) return;
			__sv.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			__sv.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) __sv.detach(div);
			if (if_block) if_block.d();
			if (default_slot) default_slot.d(detaching);
			__sv.destroy_each(each_blocks, detaching);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { title } = $$props;
	let { color = "var(--color-dark)" } = $$props;
	let { light = false } = $$props;
	let { image = false } = $$props;

	$$self.$$set = $$props => {
		if ("title" in $$props) $$invalidate(0, title = $$props.title);
		if ("color" in $$props) $$invalidate(1, color = $$props.color);
		if ("light" in $$props) $$invalidate(2, light = $$props.light);
		if ("image" in $$props) $$invalidate(3, image = $$props.image);
		if ("$$scope" in $$props) $$invalidate(4, $$scope = $$props.$$scope);
	};

	return [title, color, light, image, $$scope, slots];
}

class Faceplate extends __sv.SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-1ugmpjz-style")) add_css();
		__sv.init(this, options, instance, create_fragment, __sv.safe_not_equal, { title: 0, color: 1, light: 2, image: 3 });
	}
}

/* ../core/src/components/Label.svelte generated by Svelte v3.31.2 */


function add_css$1() {
	var style = __sv.element("style");
	style.id = "svelte-1tqe9w8-style";
	style.textContent = "div.svelte-1tqe9w8{top:100%;left:50%;position:absolute;pointer-events:none;font-family:'Routed Gothic';font-size:11px;color:inherit;white-space:nowrap}";
	__sv.append(document.head, style);
}

function create_fragment$1(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[2].default;
	const default_slot = __sv.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[1], null);

	return {
		c() {
			div = __sv.element("div");
			if (default_slot) default_slot.c();
			__sv.set_style(div, "transform", "translate(-50%, " + /*top*/ ctx[0] + "px)");
			__sv.attr(div, "class", "svelte-1tqe9w8");
		},
		m(target, anchor) {
			__sv.insert(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 2) {
					__sv.update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[1], dirty, null, null);
				}
			}

			if (!current || dirty & /*top*/ 1) {
				__sv.set_style(div, "transform", "translate(-50%, " + /*top*/ ctx[0] + "px)");
			}
		},
		i(local) {
			if (current) return;
			__sv.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			__sv.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) __sv.detach(div);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance$1($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { top = 1 } = $$props;

	$$self.$$set = $$props => {
		if ("top" in $$props) $$invalidate(0, top = $$props.top);
		if ("$$scope" in $$props) $$invalidate(1, $$scope = $$props.$$scope);
	};

	return [top, $$scope, slots];
}

class Label extends __sv.SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-1tqe9w8-style")) add_css$1();
		__sv.init(this, options, instance$1, create_fragment$1, __sv.safe_not_equal, { top: 0 });
	}
}

/* ../core/src/components/Light.svelte generated by Svelte v3.31.2 */

function add_css$2() {
	var style = __sv.element("style");
	style.id = "svelte-17lm5sf-style";
	style.textContent = "div.svelte-17lm5sf{position:absolute;width:12px;height:12px;border-radius:12px;background:var(--color-dark);border:1px solid rgba(0, 0, 0, 0.32);box-shadow:inset 2px 2px 0px rgba(255, 255, 255, 0.08), 0px 0px 0px 2px rgba(0, 0, 0, 0.12);color:inherit}div.high.svelte-17lm5sf{background:var(--color-dark-highlight)}div.square.svelte-17lm5sf{width:20px;height:20px;border-radius:3px}div.on.svelte-17lm5sf{background:hue;box-shadow:inset 2px 2px 0px rgba(255, 255, 255, 0.24), 0px 0px 0px 2px rgba(0, 0, 0, 0.12)}div.on.high.svelte-17lm5sf{background:var(--color-on-highlight)}";
	__sv.append(document.head, style);
}

// (52:2) {#if label}
function create_if_block$1(ctx) {
	let label_1;
	let current;

	label_1 = new Label({
			props: {
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			__sv.create_component(label_1.$$.fragment);
		},
		m(target, anchor) {
			__sv.mount_component(label_1, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const label_1_changes = {};

			if (dirty & /*$$scope, label*/ 260) {
				label_1_changes.$$scope = { dirty, ctx };
			}

			label_1.$set(label_1_changes);
		},
		i(local) {
			if (current) return;
			__sv.transition_in(label_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			__sv.transition_out(label_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			__sv.destroy_component(label_1, detaching);
		}
	};
}

// (53:4) <Label>
function create_default_slot(ctx) {
	let t;

	return {
		c() {
			t = __sv.text(/*label*/ ctx[2]);
		},
		m(target, anchor) {
			__sv.insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*label*/ 4) __sv.set_data(t, /*label*/ ctx[2]);
		},
		d(detaching) {
			if (detaching) __sv.detach(t);
		}
	};
}

function create_fragment$2(ctx) {
	let div;
	let current;
	let if_block = /*label*/ ctx[2] && create_if_block$1(ctx);

	return {
		c() {
			div = __sv.element("div");
			if (if_block) if_block.c();
			__sv.attr(div, "aria-label", "light");
			__sv.set_style(div, "left", /*x*/ ctx[6] + "px");
			__sv.set_style(div, "top", /*y*/ ctx[7] + "px");
			__sv.set_style(div, "background-color", /*hue*/ ctx[5]);
			__sv.attr(div, "class", "svelte-17lm5sf");
			__sv.toggle_class(div, "on", /*value*/ ctx[0] === /*set*/ ctx[1] || /*value*/ ctx[0] && typeof /*value*/ ctx[0] === "boolean");
			__sv.toggle_class(div, "square", /*square*/ ctx[3]);
			__sv.toggle_class(div, "high", /*high*/ ctx[4]);
		},
		m(target, anchor) {
			__sv.insert(target, div, anchor);
			if (if_block) if_block.m(div, null);
			current = true;
		},
		p(ctx, [dirty]) {
			if (/*label*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*label*/ 4) {
						__sv.transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$1(ctx);
					if_block.c();
					__sv.transition_in(if_block, 1);
					if_block.m(div, null);
				}
			} else if (if_block) {
				__sv.group_outros();

				__sv.transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				__sv.check_outros();
			}

			if (!current || dirty & /*x*/ 64) {
				__sv.set_style(div, "left", /*x*/ ctx[6] + "px");
			}

			if (!current || dirty & /*y*/ 128) {
				__sv.set_style(div, "top", /*y*/ ctx[7] + "px");
			}

			if (!current || dirty & /*hue*/ 32) {
				__sv.set_style(div, "background-color", /*hue*/ ctx[5]);
			}

			if (dirty & /*value, set*/ 3) {
				__sv.toggle_class(div, "on", /*value*/ ctx[0] === /*set*/ ctx[1] || /*value*/ ctx[0] && typeof /*value*/ ctx[0] === "boolean");
			}

			if (dirty & /*square*/ 8) {
				__sv.toggle_class(div, "square", /*square*/ ctx[3]);
			}

			if (dirty & /*high*/ 16) {
				__sv.toggle_class(div, "high", /*high*/ ctx[4]);
			}
		},
		i(local) {
			if (current) return;
			__sv.transition_in(if_block);
			current = true;
		},
		o(local) {
			__sv.transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) __sv.detach(div);
			if (if_block) if_block.d();
		}
	};
}

function instance$2($$self, $$props, $$invalidate) {
	let { value } = $$props;
	let { set } = $$props;
	let { label } = $$props;
	let { square } = $$props;
	let { high } = $$props;
	let { hue } = $$props;
	let { x = 0 } = $$props;
	let { y = 0 } = $$props;

	$$self.$$set = $$props => {
		if ("value" in $$props) $$invalidate(0, value = $$props.value);
		if ("set" in $$props) $$invalidate(1, set = $$props.set);
		if ("label" in $$props) $$invalidate(2, label = $$props.label);
		if ("square" in $$props) $$invalidate(3, square = $$props.square);
		if ("high" in $$props) $$invalidate(4, high = $$props.high);
		if ("hue" in $$props) $$invalidate(5, hue = $$props.hue);
		if ("x" in $$props) $$invalidate(6, x = $$props.x);
		if ("y" in $$props) $$invalidate(7, y = $$props.y);
	};

	return [value, set, label, square, high, hue, x, y];
}

class Light extends __sv.SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-17lm5sf-style")) add_css$2();

		__sv.init(this, options, instance$2, create_fragment$2, __sv.safe_not_equal, {
			value: 0,
			set: 1,
			label: 2,
			square: 3,
			high: 4,
			hue: 5,
			x: 6,
			y: 7
		});
	}
}

/* src/TIDE_ITEA.svelte generated by Svelte v3.31.2 */

function create_default_slot$1(ctx) {
	let light;
	let updating_hue;
	let updating_value;
	let t0;
	let knob0;
	let updating_value_1;
	let t1;
	let knob1;
	let updating_value_2;
	let t2;
	let knob2;
	let updating_value_3;
	let t3;
	let knob3;
	let updating_value_4;
	let t4;
	let knob4;
	let updating_value_5;
	let t5;
	let button;
	let t7;
	let patch0;
	let t8;
	let patch1;
	let current;
	let mounted;
	let dispose;

	function light_hue_binding(value) {
		/*light_hue_binding*/ ctx[5].call(null, value);
	}

	function light_value_binding(value) {
		/*light_value_binding*/ ctx[6].call(null, value);
	}

	let light_props = {
		x: 96,
		y: 56,
		label: "web",
		set: "fetched"
	};

	if (/*state*/ ctx[0].hue !== void 0) {
		light_props.hue = /*state*/ ctx[0].hue;
	}

	if (/*state*/ ctx[0].fetched !== void 0) {
		light_props.value = /*state*/ ctx[0].fetched;
	}

	light = new Light({ props: light_props });
	__sv.binding_callbacks.push(() => __sv.bind(light, "hue", light_hue_binding));
	__sv.binding_callbacks.push(() => __sv.bind(light, "value", light_value_binding));

	function knob0_value_binding(value) {
		/*knob0_value_binding*/ ctx[7].call(null, value);
	}

	let knob0_props = {
		label: "rate",
		x: 10,
		y: 60,
		min: 0.000022,
		max: 1,
		precision: 6
	};

	if (/*state*/ ctx[0].rate !== void 0) {
		knob0_props.value = /*state*/ ctx[0].rate;
	}

	knob0 = new Knob({ props: knob0_props });
	__sv.binding_callbacks.push(() => __sv.bind(knob0, "value", knob0_value_binding));

	function knob1_value_binding(value) {
		/*knob1_value_binding*/ ctx[8].call(null, value);
	}

	let knob1_props = {
		size: "s",
		label: "milli",
		x: 76,
		y: 100,
		min: 0,
		max: 100,
		precision: 2
	};

	if (/*state*/ ctx[0].milli !== void 0) {
		knob1_props.value = /*state*/ ctx[0].milli;
	}

	knob1 = new Knob({ props: knob1_props });
	__sv.binding_callbacks.push(() => __sv.bind(knob1, "value", knob1_value_binding));

	function knob2_value_binding(value) {
		/*knob2_value_binding*/ ctx[9].call(null, value);
	}

	let knob2_props = {
		size: "s",
		label: "micro",
		x: 76,
		y: 170,
		min: 0,
		max: 100,
		precision: 2
	};

	if (/*state*/ ctx[0].micro !== void 0) {
		knob2_props.value = /*state*/ ctx[0].micro;
	}

	knob2 = new Knob({ props: knob2_props });
	__sv.binding_callbacks.push(() => __sv.bind(knob2, "value", knob2_value_binding));

	function knob3_value_binding(value) {
		/*knob3_value_binding*/ ctx[10].call(null, value);
	}

	let knob3_props = {
		size: "s",
		label: "start",
		x: 18,
		y: 218,
		min: 0,
		max: 1,
		precision: 2
	};

	if (/*state*/ ctx[0].fm !== void 0) {
		knob3_props.value = /*state*/ ctx[0].fm;
	}

	knob3 = new Knob({ props: knob3_props });
	__sv.binding_callbacks.push(() => __sv.bind(knob3, "value", knob3_value_binding));

	function knob4_value_binding(value) {
		/*knob4_value_binding*/ ctx[11].call(null, value);
	}

	let knob4_props = {
		size: "s",
		label: "length",
		x: 18,
		y: 300,
		min: 1,
		max: 100,
		precision: 2
	};

	if (/*state*/ ctx[0].trimix !== void 0) {
		knob4_props.value = /*state*/ ctx[0].trimix;
	}

	knob4 = new Knob({ props: knob4_props });
	__sv.binding_callbacks.push(() => __sv.bind(knob4, "value", knob4_value_binding));

	patch0 = new Patch({
			props: {
				label: "fm",
				x: 24,
				y: 155,
				name: "signal-in",
				input: /*scale*/ ctx[1],
				onConnect: /*onConnect*/ ctx[4]
			}
		});

	patch1 = new Patch({
			props: {
				label: "out",
				x: 92,
				y: 320,
				name: "audio-out",
				output: /*player*/ ctx[2]
			}
		});

	return {
		c() {
			__sv.create_component(light.$$.fragment);
			t0 = __sv.space();
			__sv.create_component(knob0.$$.fragment);
			t1 = __sv.space();
			__sv.create_component(knob1.$$.fragment);
			t2 = __sv.space();
			__sv.create_component(knob2.$$.fragment);
			t3 = __sv.space();
			__sv.create_component(knob3.$$.fragment);
			t4 = __sv.space();
			__sv.create_component(knob4.$$.fragment);
			t5 = __sv.space();
			button = __sv.element("button");
			button.textContent = "dbg";
			t7 = __sv.space();
			__sv.create_component(patch0.$$.fragment);
			t8 = __sv.space();
			__sv.create_component(patch1.$$.fragment);
			__sv.set_style(button, "color", "#111");
			__sv.set_style(button, "background-color", "#0fa");
			__sv.set_style(button, "border-radius", "20px");
		},
		m(target, anchor) {
			__sv.mount_component(light, target, anchor);
			__sv.insert(target, t0, anchor);
			__sv.mount_component(knob0, target, anchor);
			__sv.insert(target, t1, anchor);
			__sv.mount_component(knob1, target, anchor);
			__sv.insert(target, t2, anchor);
			__sv.mount_component(knob2, target, anchor);
			__sv.insert(target, t3, anchor);
			__sv.mount_component(knob3, target, anchor);
			__sv.insert(target, t4, anchor);
			__sv.mount_component(knob4, target, anchor);
			__sv.insert(target, t5, anchor);
			__sv.insert(target, button, anchor);
			__sv.insert(target, t7, anchor);
			__sv.mount_component(patch0, target, anchor);
			__sv.insert(target, t8, anchor);
			__sv.mount_component(patch1, target, anchor);
			current = true;

			if (!mounted) {
				dispose = __sv.listen(button, "click", /*test*/ ctx[3]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			const light_changes = {};

			if (!updating_hue && dirty & /*state*/ 1) {
				updating_hue = true;
				light_changes.hue = /*state*/ ctx[0].hue;
				__sv.add_flush_callback(() => updating_hue = false);
			}

			if (!updating_value && dirty & /*state*/ 1) {
				updating_value = true;
				light_changes.value = /*state*/ ctx[0].fetched;
				__sv.add_flush_callback(() => updating_value = false);
			}

			light.$set(light_changes);
			const knob0_changes = {};

			if (!updating_value_1 && dirty & /*state*/ 1) {
				updating_value_1 = true;
				knob0_changes.value = /*state*/ ctx[0].rate;
				__sv.add_flush_callback(() => updating_value_1 = false);
			}

			knob0.$set(knob0_changes);
			const knob1_changes = {};

			if (!updating_value_2 && dirty & /*state*/ 1) {
				updating_value_2 = true;
				knob1_changes.value = /*state*/ ctx[0].milli;
				__sv.add_flush_callback(() => updating_value_2 = false);
			}

			knob1.$set(knob1_changes);
			const knob2_changes = {};

			if (!updating_value_3 && dirty & /*state*/ 1) {
				updating_value_3 = true;
				knob2_changes.value = /*state*/ ctx[0].micro;
				__sv.add_flush_callback(() => updating_value_3 = false);
			}

			knob2.$set(knob2_changes);
			const knob3_changes = {};

			if (!updating_value_4 && dirty & /*state*/ 1) {
				updating_value_4 = true;
				knob3_changes.value = /*state*/ ctx[0].fm;
				__sv.add_flush_callback(() => updating_value_4 = false);
			}

			knob3.$set(knob3_changes);
			const knob4_changes = {};

			if (!updating_value_5 && dirty & /*state*/ 1) {
				updating_value_5 = true;
				knob4_changes.value = /*state*/ ctx[0].trimix;
				__sv.add_flush_callback(() => updating_value_5 = false);
			}

			knob4.$set(knob4_changes);
			const patch0_changes = {};
			if (dirty & /*scale*/ 2) patch0_changes.input = /*scale*/ ctx[1];
			patch0.$set(patch0_changes);
			const patch1_changes = {};
			if (dirty & /*player*/ 4) patch1_changes.output = /*player*/ ctx[2];
			patch1.$set(patch1_changes);
		},
		i(local) {
			if (current) return;
			__sv.transition_in(light.$$.fragment, local);
			__sv.transition_in(knob0.$$.fragment, local);
			__sv.transition_in(knob1.$$.fragment, local);
			__sv.transition_in(knob2.$$.fragment, local);
			__sv.transition_in(knob3.$$.fragment, local);
			__sv.transition_in(knob4.$$.fragment, local);
			__sv.transition_in(patch0.$$.fragment, local);
			__sv.transition_in(patch1.$$.fragment, local);
			current = true;
		},
		o(local) {
			__sv.transition_out(light.$$.fragment, local);
			__sv.transition_out(knob0.$$.fragment, local);
			__sv.transition_out(knob1.$$.fragment, local);
			__sv.transition_out(knob2.$$.fragment, local);
			__sv.transition_out(knob3.$$.fragment, local);
			__sv.transition_out(knob4.$$.fragment, local);
			__sv.transition_out(patch0.$$.fragment, local);
			__sv.transition_out(patch1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			__sv.destroy_component(light, detaching);
			if (detaching) __sv.detach(t0);
			__sv.destroy_component(knob0, detaching);
			if (detaching) __sv.detach(t1);
			__sv.destroy_component(knob1, detaching);
			if (detaching) __sv.detach(t2);
			__sv.destroy_component(knob2, detaching);
			if (detaching) __sv.detach(t3);
			__sv.destroy_component(knob3, detaching);
			if (detaching) __sv.detach(t4);
			__sv.destroy_component(knob4, detaching);
			if (detaching) __sv.detach(t5);
			if (detaching) __sv.detach(button);
			if (detaching) __sv.detach(t7);
			__sv.destroy_component(patch0, detaching);
			if (detaching) __sv.detach(t8);
			__sv.destroy_component(patch1, detaching);
			mounted = false;
			dispose();
		}
	};
}

function create_fragment$3(ctx) {
	let faceplate;
	let current;

	faceplate = new Faceplate({
			props: {
				title: "Itea",
				color: "#563696",
				image: "../assets/itea-bg-1.svg",
				$$slots: { default: [create_default_slot$1] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			__sv.create_component(faceplate.$$.fragment);
		},
		m(target, anchor) {
			__sv.mount_component(faceplate, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const faceplate_changes = {};

			if (dirty & /*$$scope, player, scale, state*/ 131079) {
				faceplate_changes.$$scope = { dirty, ctx };
			}

			faceplate.$set(faceplate_changes);
		},
		i(local) {
			if (current) return;
			__sv.transition_in(faceplate.$$.fragment, local);
			current = true;
		},
		o(local) {
			__sv.transition_out(faceplate.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			__sv.destroy_component(faceplate, detaching);
		}
	};
}

const MIN = 0;
const MAX = 1;

function instance$3($$self, $$props, $$invalidate) {
	var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
		function adopt(value) {
			return value instanceof P
			? value
			: new P(function (resolve) {
						resolve(value);
					});
		}

		return new (P || (P = Promise))(function (resolve, reject) {
				function fulfilled(value) {
					try {
						step(generator.next(value));
					} catch(e) {
						reject(e);
					}
				}

				function rejected(value) {
					try {
						step(generator["throw"](value));
					} catch(e) {
						reject(e);
					}
				}

				function step(result) {
					result.done
					? resolve(result.value)
					: adopt(result.value).then(fulfilled, rejected);
				}

				step((generator = generator.apply(thisArg, _arguments || [])).next());
			});
	};

	
	console.log("../../src/itea_bg.svg");

	let { state = {
		freq: 440,
		type: "sine",
		fm: 1,
		trimix: 0.5,
		fetched: false,
		data: null,
		hue: "#ffc75e",
		rate: 1,
		milli: 0,
		micro: 0
	} } = $$props;

	const crossFade = new Tone.CrossFade();
	const osc1 = new Tone.Oscillator(state.freq, state.type).connect(crossFade.a).start();
	const osc2 = new Tone.Oscillator(state.freq, "sawtooth").connect(crossFade.b).start();
	const scale = new Tone.Scale(MIN, MAX);

	// const map = (num, in_min, in_max, out_min, out_max) => {
	//   return (num - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
	// }
	let buffer;

	let player = new Tone.Player();

	// let player = new Player('https://upload.wikimedia.org/wikipedia/commons/8/80/Field_cricket_Gryllus_pennsylvanicus.ogg')
	onMount(() => __awaiter(void 0, void 0, void 0, function* () {
		try {
			let corsProxy = `http://localhost:8080/`;
			let fetchUrl = `http://www.ioc-sealevelmonitoring.org/service.php?query=data&format=json&code=${"itea"}&includesensors[]=rad&timestop=now&timestart=`;
			let today = new Date();
			let minute = 60 * 1000;
			let tidalperiod = 745 * minute;
			let twoweeks = minute * 20160;
			let tidemonth = 2 * twoweeks;
			let tidemonthago = today - tidemonth;
			let tideperiodago = today - tidalperiod;
			let y = new Date(tideperiodago);
			let dateQuery = y.toISOString().slice(0, 16);

			const res = yield fetch(corsProxy + fetchUrl + dateQuery, {
				method: "GET",
				headers: {
					"Content-Type": "application/json",
					"Origin": "http://localhost:3000"
				}
			});

			const data = yield res.json();
			$$invalidate(0, state.data = data, state);
			$$invalidate(0, state.fetched = true, state);
			console.log(state.data);
			$$invalidate(0, state.hue = "#42a4ff", state);

			// buffer = new ToneAudioBuffer().fromArray(new Float32Array(44100))
			buffer = new Tone.ToneAudioBuffer().fromArray(new Float32Array(state.data.length));

			// buffer.numberOfChannels += 1
			for (var channel = 0; channel < buffer.numberOfChannels; channel++) {
				// This gives us the actual array that contains the data
				var nowBuffering = buffer.getChannelData(channel);

				for (var i = 0; i < buffer.length; i++) {
					// Math.random() is in [0; 1.0]
					// audio needs to be in [-1.0; 1.0]
					// nowBuffering[i] = Math.random() * 2 - 1;
					nowBuffering[i] = state.data[i].slevel;
				}
			}

			// player = new Player('https://upload.wikimedia.org/wikipedia/commons/8/80/Field_cricket_Gryllus_pennsylvanicus.ogg')
			$$invalidate(2, player = new Tone.Player(buffer));

			// player.load(buffer)
			if (player.loaded) {
				player.start();
			} else {
				$$invalidate(2, player.autostart = true, player);
			}

			$$invalidate(2, player.loop = true, player);

			// console.log(buffer)
			console.log(player.playbackRate);
		} catch(err) {
			console.log(err); // console.log(player.loaded)
			$$invalidate(0, state.hue = "#eb3495", state);
		}
	}));

	const test = e => {
		let milliAdjust = state.milli / 1000;
		let microAdjust = state.micro / 1000000;
		console.log(state.rate + milliAdjust + microAdjust);
	};

	const onConnect = nodes => {
		if (nodes) {
			scale.connect(osc1.frequency);
			scale.connect(osc2.frequency);
		} else {
			scale.disconnect(osc1.frequency);
			osc1.frequency.overridden = false;
			osc1.frequency.value = state.freq;
			scale.disconnect(osc2.frequency);
			osc2.frequency.overridden = false;
			osc2.frequency.value = state.freq;
		}
	};

	function light_hue_binding(value) {
		state.hue = value;
		$$invalidate(0, state);
	}

	function light_value_binding(value) {
		state.fetched = value;
		$$invalidate(0, state);
	}

	function knob0_value_binding(value) {
		state.rate = value;
		$$invalidate(0, state);
	}

	function knob1_value_binding(value) {
		state.milli = value;
		$$invalidate(0, state);
	}

	function knob2_value_binding(value) {
		state.micro = value;
		$$invalidate(0, state);
	}

	function knob3_value_binding(value) {
		state.fm = value;
		$$invalidate(0, state);
	}

	function knob4_value_binding(value) {
		state.trimix = value;
		$$invalidate(0, state);
	}

	$$self.$$set = $$props => {
		if ("state" in $$props) $$invalidate(0, state = $$props.state);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*state*/ 1) {
			// $: osc1.frequency.value = state.freq;
			// $: osc1.frequency.value = state.rate;
			 $$invalidate(2, player.playbackRate = state.rate + state.milli / 1000 + state.micro / 1000000, player);
		}

		if ($$self.$$.dirty & /*state*/ 1) {
			 osc2.frequency.value = state.freq;
		}

		if ($$self.$$.dirty & /*state*/ 1) {
			 osc1.type = state.type;
		}

		if ($$self.$$.dirty & /*state*/ 1) {
			 crossFade.fade.value = state.trimix;
		}

		if ($$self.$$.dirty & /*state*/ 1) {
			// $: scale.min = Math.max(MIN, state.freq - state.freq * state.fm);
			// $: scale.max = Math.min(MAX, state.freq + (MAX - state.freq) * state.fm);
			 $$invalidate(1, scale.min = Math.max(MIN, state.rate - state.rate * state.fm), scale);
		}

		if ($$self.$$.dirty & /*state*/ 1) {
			 $$invalidate(1, scale.max = Math.min(MAX, state.rate + (MAX - state.rate) * state.fm), scale);
		}
	};

	return [
		state,
		scale,
		player,
		test,
		onConnect,
		light_hue_binding,
		light_value_binding,
		knob0_value_binding,
		knob1_value_binding,
		knob2_value_binding,
		knob3_value_binding,
		knob4_value_binding
	];
}

class TIDE_ITEA extends __sv.SvelteComponent {
	constructor(options) {
		super();
		__sv.init(this, options, instance$3, create_fragment$3, __sv.safe_not_equal, { state: 0 });
	}
}

export default TIDE_ITEA;
