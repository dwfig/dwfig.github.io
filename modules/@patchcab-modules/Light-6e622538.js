
(function(l, r) { if (l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (window.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(window.document);
/* ../core/src/components/Faceplate.svelte generated by Svelte v3.31.2 */


function add_css() {
	var style = __sv.element("style");
	style.id = "svelte-1ugmpjz-style";
	style.textContent = "div.svelte-1ugmpjz{display:block;width:100%;height:100%;position:relative}h1.svelte-1ugmpjz,svg.svelte-1ugmpjz{pointer-events:none}h1.svelte-1ugmpjz{font-family:'Routed Gothic Wide';font-size:14px;line-height:14px;position:absolute;text-align:center;top:24px;width:100%}svg.svelte-1ugmpjz{position:absolute;opacity:0.4}.screw-1.svelte-1ugmpjz,.screw-2.svelte-1ugmpjz{top:2px}.screw-3.svelte-1ugmpjz,.screw-4.svelte-1ugmpjz{bottom:3px}.screw-1.svelte-1ugmpjz,.screw-3.svelte-1ugmpjz{left:2px}.screw-2.svelte-1ugmpjz,.screw-4.svelte-1ugmpjz{right:2px}";
	__sv.append(document.head, style);
}

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[6] = list[i];
	return child_ctx;
}

// (57:2) {#if title}
function create_if_block(ctx) {
	let h1;
	let t;

	return {
		c() {
			h1 = __sv.element("h1");
			t = __sv.text(/*title*/ ctx[0]);
			__sv.attr(h1, "class", "svelte-1ugmpjz");
		},
		m(target, anchor) {
			__sv.insert(target, h1, anchor);
			__sv.append(h1, t);
		},
		p(ctx, dirty) {
			if (dirty & /*title*/ 1) __sv.set_data(t, /*title*/ ctx[0]);
		},
		d(detaching) {
			if (detaching) __sv.detach(h1);
		}
	};
}

// (61:2) {#each [1, 2, 3, 4] as index}
function create_each_block(ctx) {
	let svg;
	let path;

	return {
		c() {
			svg = __sv.svg_element("svg");
			path = __sv.svg_element("path");
			__sv.attr(path, "d", "M6 12A6 6 0 106 0a6 6 0 000 12zm5-6A5 5 0 111 6a5 5 0 0110 0zM4 4.667L4.667 4 6 5.333 7.333 4 8 4.667 6.667 6\n\t\t\t\t8 7.333 7.333 8 6 6.667 4.667 8 4 7.333 5.333 6 4 4.667z");
			__sv.attr(path, "fill", "currentColor");
			__sv.attr(svg, "class", "" + (__sv.null_to_empty(`screw-${/*index*/ ctx[6]}`) + " svelte-1ugmpjz"));
			__sv.attr(svg, "width", "12");
			__sv.attr(svg, "height", "12");
			__sv.attr(svg, "fill", "none");
			__sv.attr(svg, "xmlns", "http://www.w3.org/2000/svg");
		},
		m(target, anchor) {
			__sv.insert(target, svg, anchor);
			__sv.append(svg, path);
		},
		d(detaching) {
			if (detaching) __sv.detach(svg);
		}
	};
}

function create_fragment(ctx) {
	let div;
	let t0;
	let t1;
	let current;
	let if_block = /*title*/ ctx[0] && create_if_block(ctx);
	const default_slot_template = /*#slots*/ ctx[5].default;
	const default_slot = __sv.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);
	let each_value = [1, 2, 3, 4];
	let each_blocks = [];

	for (let i = 0; i < 4; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	return {
		c() {
			div = __sv.element("div");
			if (if_block) if_block.c();
			t0 = __sv.space();
			if (default_slot) default_slot.c();
			t1 = __sv.space();

			for (let i = 0; i < 4; i += 1) {
				each_blocks[i].c();
			}

			__sv.attr(div, "draggable", "");
			__sv.set_style(div, "background-repeat", "no-repeat");
			__sv.set_style(div, "background-color", /*color*/ ctx[1]);
			__sv.set_style(div, "background-image", (/*image*/ ctx[3] ? `url('${/*image*/ ctx[3]}')` : `none`) + " ");
			__sv.set_style(div, "color", "var(--color-" + (/*light*/ ctx[2] ? "dark" : "light") + ")");
			__sv.attr(div, "class", "svelte-1ugmpjz");
		},
		m(target, anchor) {
			__sv.insert(target, div, anchor);
			if (if_block) if_block.m(div, null);
			__sv.append(div, t0);

			if (default_slot) {
				default_slot.m(div, null);
			}

			__sv.append(div, t1);

			for (let i = 0; i < 4; i += 1) {
				each_blocks[i].m(div, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (/*title*/ ctx[0]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					if_block.m(div, t0);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 16) {
					__sv.update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[4], dirty, null, null);
				}
			}

			if (!current || dirty & /*color*/ 2) {
				__sv.set_style(div, "background-color", /*color*/ ctx[1]);
			}

			if (!current || dirty & /*image*/ 8) {
				__sv.set_style(div, "background-image", (/*image*/ ctx[3] ? `url('${/*image*/ ctx[3]}')` : `none`) + " ");
			}

			if (!current || dirty & /*light*/ 4) {
				__sv.set_style(div, "color", "var(--color-" + (/*light*/ ctx[2] ? "dark" : "light") + ")");
			}
		},
		i(local) {
			if (current) return;
			__sv.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			__sv.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) __sv.detach(div);
			if (if_block) if_block.d();
			if (default_slot) default_slot.d(detaching);
			__sv.destroy_each(each_blocks, detaching);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { title } = $$props;
	let { color = "var(--color-dark)" } = $$props;
	let { light = false } = $$props;
	let { image = false } = $$props;

	$$self.$$set = $$props => {
		if ("title" in $$props) $$invalidate(0, title = $$props.title);
		if ("color" in $$props) $$invalidate(1, color = $$props.color);
		if ("light" in $$props) $$invalidate(2, light = $$props.light);
		if ("image" in $$props) $$invalidate(3, image = $$props.image);
		if ("$$scope" in $$props) $$invalidate(4, $$scope = $$props.$$scope);
	};

	return [title, color, light, image, $$scope, slots];
}

class Faceplate extends __sv.SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-1ugmpjz-style")) add_css();
		__sv.init(this, options, instance, create_fragment, __sv.safe_not_equal, { title: 0, color: 1, light: 2, image: 3 });
	}
}

/* ../core/src/components/Label.svelte generated by Svelte v3.31.2 */


function add_css$1() {
	var style = __sv.element("style");
	style.id = "svelte-1tqe9w8-style";
	style.textContent = "div.svelte-1tqe9w8{top:100%;left:50%;position:absolute;pointer-events:none;font-family:'Routed Gothic';font-size:11px;color:inherit;white-space:nowrap}";
	__sv.append(document.head, style);
}

function create_fragment$1(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[2].default;
	const default_slot = __sv.create_slot(default_slot_template, ctx, /*$$scope*/ ctx[1], null);

	return {
		c() {
			div = __sv.element("div");
			if (default_slot) default_slot.c();
			__sv.set_style(div, "transform", "translate(-50%, " + /*top*/ ctx[0] + "px)");
			__sv.attr(div, "class", "svelte-1tqe9w8");
		},
		m(target, anchor) {
			__sv.insert(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 2) {
					__sv.update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[1], dirty, null, null);
				}
			}

			if (!current || dirty & /*top*/ 1) {
				__sv.set_style(div, "transform", "translate(-50%, " + /*top*/ ctx[0] + "px)");
			}
		},
		i(local) {
			if (current) return;
			__sv.transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			__sv.transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) __sv.detach(div);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance$1($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { top = 1 } = $$props;

	$$self.$$set = $$props => {
		if ("top" in $$props) $$invalidate(0, top = $$props.top);
		if ("$$scope" in $$props) $$invalidate(1, $$scope = $$props.$$scope);
	};

	return [top, $$scope, slots];
}

class Label extends __sv.SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-1tqe9w8-style")) add_css$1();
		__sv.init(this, options, instance$1, create_fragment$1, __sv.safe_not_equal, { top: 0 });
	}
}

/* ../core/src/components/Light.svelte generated by Svelte v3.31.2 */

function add_css$2() {
	var style = __sv.element("style");
	style.id = "svelte-17lm5sf-style";
	style.textContent = "div.svelte-17lm5sf{position:absolute;width:12px;height:12px;border-radius:12px;background:var(--color-dark);border:1px solid rgba(0, 0, 0, 0.32);box-shadow:inset 2px 2px 0px rgba(255, 255, 255, 0.08), 0px 0px 0px 2px rgba(0, 0, 0, 0.12);color:inherit}div.high.svelte-17lm5sf{background:var(--color-dark-highlight)}div.square.svelte-17lm5sf{width:20px;height:20px;border-radius:3px}div.on.svelte-17lm5sf{background:hue;box-shadow:inset 2px 2px 0px rgba(255, 255, 255, 0.24), 0px 0px 0px 2px rgba(0, 0, 0, 0.12)}div.on.high.svelte-17lm5sf{background:var(--color-on-highlight)}";
	__sv.append(document.head, style);
}

// (52:2) {#if label}
function create_if_block$1(ctx) {
	let label_1;
	let current;

	label_1 = new Label({
			props: {
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			__sv.create_component(label_1.$$.fragment);
		},
		m(target, anchor) {
			__sv.mount_component(label_1, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const label_1_changes = {};

			if (dirty & /*$$scope, label*/ 260) {
				label_1_changes.$$scope = { dirty, ctx };
			}

			label_1.$set(label_1_changes);
		},
		i(local) {
			if (current) return;
			__sv.transition_in(label_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			__sv.transition_out(label_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			__sv.destroy_component(label_1, detaching);
		}
	};
}

// (53:4) <Label>
function create_default_slot(ctx) {
	let t;

	return {
		c() {
			t = __sv.text(/*label*/ ctx[2]);
		},
		m(target, anchor) {
			__sv.insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*label*/ 4) __sv.set_data(t, /*label*/ ctx[2]);
		},
		d(detaching) {
			if (detaching) __sv.detach(t);
		}
	};
}

function create_fragment$2(ctx) {
	let div;
	let current;
	let if_block = /*label*/ ctx[2] && create_if_block$1(ctx);

	return {
		c() {
			div = __sv.element("div");
			if (if_block) if_block.c();
			__sv.attr(div, "aria-label", "light");
			__sv.set_style(div, "left", /*x*/ ctx[6] + "px");
			__sv.set_style(div, "top", /*y*/ ctx[7] + "px");
			__sv.set_style(div, "background-color", /*hue*/ ctx[5]);
			__sv.attr(div, "class", "svelte-17lm5sf");
			__sv.toggle_class(div, "on", /*value*/ ctx[0] === /*set*/ ctx[1] || /*value*/ ctx[0] && typeof /*value*/ ctx[0] === "boolean");
			__sv.toggle_class(div, "square", /*square*/ ctx[3]);
			__sv.toggle_class(div, "high", /*high*/ ctx[4]);
		},
		m(target, anchor) {
			__sv.insert(target, div, anchor);
			if (if_block) if_block.m(div, null);
			current = true;
		},
		p(ctx, [dirty]) {
			if (/*label*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*label*/ 4) {
						__sv.transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$1(ctx);
					if_block.c();
					__sv.transition_in(if_block, 1);
					if_block.m(div, null);
				}
			} else if (if_block) {
				__sv.group_outros();

				__sv.transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				__sv.check_outros();
			}

			if (!current || dirty & /*x*/ 64) {
				__sv.set_style(div, "left", /*x*/ ctx[6] + "px");
			}

			if (!current || dirty & /*y*/ 128) {
				__sv.set_style(div, "top", /*y*/ ctx[7] + "px");
			}

			if (!current || dirty & /*hue*/ 32) {
				__sv.set_style(div, "background-color", /*hue*/ ctx[5]);
			}

			if (dirty & /*value, set*/ 3) {
				__sv.toggle_class(div, "on", /*value*/ ctx[0] === /*set*/ ctx[1] || /*value*/ ctx[0] && typeof /*value*/ ctx[0] === "boolean");
			}

			if (dirty & /*square*/ 8) {
				__sv.toggle_class(div, "square", /*square*/ ctx[3]);
			}

			if (dirty & /*high*/ 16) {
				__sv.toggle_class(div, "high", /*high*/ ctx[4]);
			}
		},
		i(local) {
			if (current) return;
			__sv.transition_in(if_block);
			current = true;
		},
		o(local) {
			__sv.transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) __sv.detach(div);
			if (if_block) if_block.d();
		}
	};
}

function instance$2($$self, $$props, $$invalidate) {
	let { value } = $$props;
	let { set } = $$props;
	let { label } = $$props;
	let { square } = $$props;
	let { high } = $$props;
	let { hue } = $$props;
	let { x = 0 } = $$props;
	let { y = 0 } = $$props;

	$$self.$$set = $$props => {
		if ("value" in $$props) $$invalidate(0, value = $$props.value);
		if ("set" in $$props) $$invalidate(1, set = $$props.set);
		if ("label" in $$props) $$invalidate(2, label = $$props.label);
		if ("square" in $$props) $$invalidate(3, square = $$props.square);
		if ("high" in $$props) $$invalidate(4, high = $$props.high);
		if ("hue" in $$props) $$invalidate(5, hue = $$props.hue);
		if ("x" in $$props) $$invalidate(6, x = $$props.x);
		if ("y" in $$props) $$invalidate(7, y = $$props.y);
	};

	return [value, set, label, square, high, hue, x, y];
}

class Light extends __sv.SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-17lm5sf-style")) add_css$2();

		__sv.init(this, options, instance$2, create_fragment$2, __sv.safe_not_equal, {
			value: 0,
			set: 1,
			label: 2,
			square: 3,
			high: 4,
			hue: 5,
			x: 6,
			y: 7
		});
	}
}

export { Faceplate as F, Light as L, Label as a };
