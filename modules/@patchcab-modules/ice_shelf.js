
(function(l, r) { if (l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (window.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(window.document);
import { onMount, Knob, Patch } from '/js/core.js';
import { F as Faceplate, L as Light } from './Light-6e622538.js';

/* src/ICE_SHELF.svelte generated by Svelte v3.31.2 */

function create_default_slot(ctx) {
	let light;
	let updating_hue;
	let updating_value;
	let t0;
	let knob0;
	let updating_value_1;
	let t1;
	let knob1;
	let updating_value_2;
	let t2;
	let button;
	let t4;
	let patch0;
	let t5;
	let patch1;
	let t6;
	let patch2;
	let current;
	let mounted;
	let dispose;

	function light_hue_binding(value) {
		/*light_hue_binding*/ ctx[7].call(null, value);
	}

	function light_value_binding(value) {
		/*light_value_binding*/ ctx[8].call(null, value);
	}

	let light_props = {
		x: 96,
		y: 56,
		label: "web",
		set: "fetched"
	};

	if (/*state*/ ctx[0].hue !== void 0) {
		light_props.hue = /*state*/ ctx[0].hue;
	}

	if (/*state*/ ctx[0].fetched !== void 0) {
		light_props.value = /*state*/ ctx[0].fetched;
	}

	light = new Light({ props: light_props });
	__sv.binding_callbacks.push(() => __sv.bind(light, "hue", light_hue_binding));
	__sv.binding_callbacks.push(() => __sv.bind(light, "value", light_value_binding));

	function knob0_value_binding(value) {
		/*knob0_value_binding*/ ctx[9].call(null, value);
	}

	let knob0_props = {
		label: "rate",
		x: 10,
		y: 60,
		min: 0.000022,
		max: 1,
		precision: 6
	};

	if (/*state*/ ctx[0].rate !== void 0) {
		knob0_props.value = /*state*/ ctx[0].rate;
	}

	knob0 = new Knob({ props: knob0_props });
	__sv.binding_callbacks.push(() => __sv.bind(knob0, "value", knob0_value_binding));

	function knob1_value_binding(value) {
		/*knob1_value_binding*/ ctx[10].call(null, value);
	}

	let knob1_props = {
		label: "year",
		x: 66,
		y: 98,
		min: 1,
		max: 42,
		steps: 41
	};

	if (/*state*/ ctx[0].year !== void 0) {
		knob1_props.value = /*state*/ ctx[0].year;
	}

	knob1 = new Knob({ props: knob1_props });
	__sv.binding_callbacks.push(() => __sv.bind(knob1, "value", knob1_value_binding));

	patch0 = new Patch({
			props: {
				label: "year",
				x: 24,
				y: 200,
				name: "year-in",
				input: /*node*/ ctx[3],
				onConnect: /*onYearConnect*/ ctx[4]
			}
		});

	patch1 = new Patch({
			props: {
				label: "fm",
				x: 24,
				y: 155,
				name: "signal-in",
				input: /*scale*/ ctx[1],
				onConnect: /*onConnect*/ ctx[6]
			}
		});

	patch2 = new Patch({
			props: {
				label: "out",
				x: 92,
				y: 320,
				name: "audio-out",
				output: /*player*/ ctx[2]
			}
		});

	return {
		c() {
			__sv.create_component(light.$$.fragment);
			t0 = __sv.space();
			__sv.create_component(knob0.$$.fragment);
			t1 = __sv.space();
			__sv.create_component(knob1.$$.fragment);
			t2 = __sv.space();
			button = __sv.element("button");
			button.textContent = "dbg";
			t4 = __sv.space();
			__sv.create_component(patch0.$$.fragment);
			t5 = __sv.space();
			__sv.create_component(patch1.$$.fragment);
			t6 = __sv.space();
			__sv.create_component(patch2.$$.fragment);
			__sv.set_style(button, "color", "#111");
			__sv.set_style(button, "background-color", "#0fa");
			__sv.set_style(button, "border-radius", "20px");
		},
		m(target, anchor) {
			__sv.mount_component(light, target, anchor);
			__sv.insert(target, t0, anchor);
			__sv.mount_component(knob0, target, anchor);
			__sv.insert(target, t1, anchor);
			__sv.mount_component(knob1, target, anchor);
			__sv.insert(target, t2, anchor);
			__sv.insert(target, button, anchor);
			__sv.insert(target, t4, anchor);
			__sv.mount_component(patch0, target, anchor);
			__sv.insert(target, t5, anchor);
			__sv.mount_component(patch1, target, anchor);
			__sv.insert(target, t6, anchor);
			__sv.mount_component(patch2, target, anchor);
			current = true;

			if (!mounted) {
				dispose = __sv.listen(button, "click", /*test*/ ctx[5]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			const light_changes = {};

			if (!updating_hue && dirty & /*state*/ 1) {
				updating_hue = true;
				light_changes.hue = /*state*/ ctx[0].hue;
				__sv.add_flush_callback(() => updating_hue = false);
			}

			if (!updating_value && dirty & /*state*/ 1) {
				updating_value = true;
				light_changes.value = /*state*/ ctx[0].fetched;
				__sv.add_flush_callback(() => updating_value = false);
			}

			light.$set(light_changes);
			const knob0_changes = {};

			if (!updating_value_1 && dirty & /*state*/ 1) {
				updating_value_1 = true;
				knob0_changes.value = /*state*/ ctx[0].rate;
				__sv.add_flush_callback(() => updating_value_1 = false);
			}

			knob0.$set(knob0_changes);
			const knob1_changes = {};

			if (!updating_value_2 && dirty & /*state*/ 1) {
				updating_value_2 = true;
				knob1_changes.value = /*state*/ ctx[0].year;
				__sv.add_flush_callback(() => updating_value_2 = false);
			}

			knob1.$set(knob1_changes);
			const patch1_changes = {};
			if (dirty & /*scale*/ 2) patch1_changes.input = /*scale*/ ctx[1];
			patch1.$set(patch1_changes);
			const patch2_changes = {};
			if (dirty & /*player*/ 4) patch2_changes.output = /*player*/ ctx[2];
			patch2.$set(patch2_changes);
		},
		i(local) {
			if (current) return;
			__sv.transition_in(light.$$.fragment, local);
			__sv.transition_in(knob0.$$.fragment, local);
			__sv.transition_in(knob1.$$.fragment, local);
			__sv.transition_in(patch0.$$.fragment, local);
			__sv.transition_in(patch1.$$.fragment, local);
			__sv.transition_in(patch2.$$.fragment, local);
			current = true;
		},
		o(local) {
			__sv.transition_out(light.$$.fragment, local);
			__sv.transition_out(knob0.$$.fragment, local);
			__sv.transition_out(knob1.$$.fragment, local);
			__sv.transition_out(patch0.$$.fragment, local);
			__sv.transition_out(patch1.$$.fragment, local);
			__sv.transition_out(patch2.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			__sv.destroy_component(light, detaching);
			if (detaching) __sv.detach(t0);
			__sv.destroy_component(knob0, detaching);
			if (detaching) __sv.detach(t1);
			__sv.destroy_component(knob1, detaching);
			if (detaching) __sv.detach(t2);
			if (detaching) __sv.detach(button);
			if (detaching) __sv.detach(t4);
			__sv.destroy_component(patch0, detaching);
			if (detaching) __sv.detach(t5);
			__sv.destroy_component(patch1, detaching);
			if (detaching) __sv.detach(t6);
			__sv.destroy_component(patch2, detaching);
			mounted = false;
			dispose();
		}
	};
}

function create_fragment(ctx) {
	let faceplate;
	let current;

	faceplate = new Faceplate({
			props: {
				title: "Ice Shelf",
				color: "#3fbbd1",
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			__sv.create_component(faceplate.$$.fragment);
		},
		m(target, anchor) {
			__sv.mount_component(faceplate, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const faceplate_changes = {};

			if (dirty & /*$$scope, player, scale, state*/ 2097159) {
				faceplate_changes.$$scope = { dirty, ctx };
			}

			faceplate.$set(faceplate_changes);
		},
		i(local) {
			if (current) return;
			__sv.transition_in(faceplate.$$.fragment, local);
			current = true;
		},
		o(local) {
			__sv.transition_out(faceplate.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			__sv.destroy_component(faceplate, detaching);
		}
	};
}

const MIN = 0;
const MAX = 1;

function instance($$self, $$props, $$invalidate) {
	var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
		function adopt(value) {
			return value instanceof P
			? value
			: new P(function (resolve) {
						resolve(value);
					});
		}

		return new (P || (P = Promise))(function (resolve, reject) {
				function fulfilled(value) {
					try {
						step(generator.next(value));
					} catch(e) {
						reject(e);
					}
				}

				function rejected(value) {
					try {
						step(generator["throw"](value));
					} catch(e) {
						reject(e);
					}
				}

				function step(result) {
					result.done
					? resolve(result.value)
					: adopt(result.value).then(fulfilled, rejected);
				}

				step((generator = generator.apply(thisArg, _arguments || [])).next());
			});
	};

	
	console.log("../../src/itea_bg.svg");
	let node = new Tone.Waveform(512);

	let { state = {
		freq: 440,
		type: "sine",
		fm: 1,
		trimix: 0.5,
		fetched: false,
		arctic: null,
		antarctic: null,
		hue: "#ffc75e",
		rate: 1,
		milli: 0,
		micro: 0,
		year: 1
	} } = $$props;

	const crossFade = new Tone.CrossFade();
	const osc1 = new Tone.Oscillator(state.freq, state.type).connect(crossFade.a).start();
	const osc2 = new Tone.Oscillator(state.freq, "sawtooth").connect(crossFade.b).start();
	const scale = new Tone.Scale(MIN, MAX);
	let buffers = [];
	let running;

	// let buffers = {}
	const remap = (num, in_min, in_max, out_min, out_max) => {
		return (num - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
	};
	let player = new Tone.Player();

	// let player = new Player('https://upload.wikimedia.org/wikipedia/commons/8/80/Field_cricket_Gryllus_pennsylvanicus.ogg')
	const loop = () => {
		if (!running) {
			return;
		}

		requestAnimationFrame(loop);
		const wave = node.getValue();
		let newYear;

		// if (state.bipolar){
		newYear = Math.round(remap(wave[0], -1, 1, 1, 42));

		// } else {
		//   newYear = Math.round(remap(wave[0], 0, 1, 1, 42))
		// }
		if (state.year != newYear) {
			$$invalidate(0, state.year = newYear, state);
		}
	};

	const onYearConnect = nodes => {
		if (nodes) {
			running = true;
			loop();
		} else {
			running = false;
		}

		console.log("connected to year");
	};

	onMount(() => __awaiter(void 0, void 0, void 0, function* () {
		try {
			const res = yield fetch("../../../assets/ice-shelfs.json", {
				method: "GET",
				headers: { "Content-Type": "application/json" }
			});

			let data = yield res.json();

			// data = data.reverse()
			// console.log(data)
			// for(let i = 0 ; i < data.length ; i ++){
			//   incomeData[i] = data[i]["Month Income"]
			// }
			// console.log(data[0])
			$$invalidate(0, state.arctic = data[0]["arctic"], state);

			$$invalidate(0, state.antarctic = data[0]["antarctic"], state);

			// make a new entry in buffers
			// for every year, load them when the module calls for them
			// console.log(state.arctic[Object.keys(state.arctic)[0]])
			for (let i = 0; i < Object.keys(state.antarctic).length; i++) {
				let year = Object.keys(state.antarctic)[i];
				let days = Object.keys(state.antarctic[year]);

				// console.log(days)
				buffers[i] = new Tone.ToneAudioBuffer().fromArray(new Float32Array(days.length));

				for (let channel = 0; channel < buffers[i].numberOfChannels; channel++) {
					// This gives us the actual array that contains the data
					let nowBuffering = buffers[i].getChannelData(channel);

					for (let j = 0; j < buffers[i].length; j++) {
						// nowBuffering[i] = state.data[i].slevel
						// console.log(buffers[i].length)
						// console.log(days[j])
						// console.log(state.arctic[year][days[j]])
						nowBuffering[j] = state.antarctic[year][days[j]];
					}
				}
			}

			// console.log(buffers)
			// player = new Player('https://upload.wikimedia.org/wikipedia/commons/8/80/Field_cricket_Gryllus_pennsylvanicus.ogg')
			$$invalidate(2, player = new Tone.Player(buffers[5]));

			// player.load(buffer)
			if (player.loaded) {
				player.start();
			} else {
				$$invalidate(2, player.autostart = true, player);
			}

			$$invalidate(2, player.loop = true, player);

			// // console.log(buffer)
			// // console.log(player.playbackRate)
			// // console.log(player.loaded)
			$$invalidate(0, state.fetched = true, state);

			$$invalidate(0, state.hue = "#42a4ff", state);
		} catch(err) {
			console.log(err);
			$$invalidate(0, state.hue = "#eb3495", state);
		} // here, load local json
	}));

	const setBuffer = () => {
		//   // let milliAdjust = state.milli / 1000
		//   // let microAdjust = state.micro / 1000000
		//   // console.log(tides)
		//   // player.load(buffers[1])
		//   // player.buffer = buffers[1]
		// player.load('https://upload.wikimedia.org/wikipedia/commons/8/80/Field_cricket_Gryllus_pennsylvanicus.ogg')
		// state.year += 1
		// console.log(buffers[state.year])
		player.stop();

		$$invalidate(2, player.buffer = buffers[state.year], player);

		// player.load(buffers[state.year])
		// .then(() => {
		// player.restart()
		//   player.autostart = true;
		//   console.log(player)
		// })
		if (player.loaded) {
			player.start();
		} else {
			$$invalidate(2, player.autostart = true, player);
		}

		$$invalidate(2, player.loop = true, player);
	};

	const test = e => {
		console.log("debug");
	};

	const onConnect = nodes => {
		if (nodes) {
			// scale.connect(osc1.frequency);
			scale.connect(rate);

			scale.connect(osc2.frequency);
		} else {
			scale.disconnect(osc1.frequency);
			scale.disconnect(rate);
			osc1.frequency.overridden = false;
			osc1.frequency.value = state.freq;
			scale.disconnect(osc2.frequency);
			osc2.frequency.overridden = false;
			osc2.frequency.value = state.freq;
		}
	};

	function light_hue_binding(value) {
		state.hue = value;
		$$invalidate(0, state);
	}

	function light_value_binding(value) {
		state.fetched = value;
		$$invalidate(0, state);
	}

	function knob0_value_binding(value) {
		state.rate = value;
		$$invalidate(0, state);
	}

	function knob1_value_binding(value) {
		state.year = value;
		$$invalidate(0, state);
	}

	$$self.$$set = $$props => {
		if ("state" in $$props) $$invalidate(0, state = $$props.state);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*state*/ 1) {
			// $: osc1.frequency.value = state.freq;
			// $: osc1.frequency.value = state.rate;
			 $$invalidate(2, player.playbackRate = state.rate + state.milli / 1000 + state.micro / 1000000, player);
		}

		if ($$self.$$.dirty & /*state*/ 1) {
			 osc2.frequency.value = state.freq;
		}

		if ($$self.$$.dirty & /*state*/ 1) {
			 osc1.type = state.type;
		}

		if ($$self.$$.dirty & /*state*/ 1) {
			 crossFade.fade.value = state.trimix;
		}

		if ($$self.$$.dirty & /*state*/ 1) {
			 (state.year, setBuffer());
		}

		if ($$self.$$.dirty & /*state*/ 1) {
			// $ : {
			//     player.stop()
			//     // player.load(buffers[state.year])
			//     player = new Player(buffers[state.year])
			//     console.log(state.year)
			//     player.restart()
			// }
			// console.log(buffers[4])
			// $: scale.min = Math.max(MIN, state.freq - state.freq * state.fm);
			// $: scale.max = Math.min(MAX, state.freq + (MAX - state.freq) * state.fm);
			 $$invalidate(1, scale.min = Math.max(MIN, state.rate - state.rate * state.fm), scale);
		}

		if ($$self.$$.dirty & /*state*/ 1) {
			 $$invalidate(1, scale.max = Math.min(MAX, state.rate + (MAX - state.rate) * state.fm), scale);
		}
	};

	return [
		state,
		scale,
		player,
		node,
		onYearConnect,
		test,
		onConnect,
		light_hue_binding,
		light_value_binding,
		knob0_value_binding,
		knob1_value_binding
	];
}

class ICE_SHELF extends __sv.SvelteComponent {
	constructor(options) {
		super();
		__sv.init(this, options, instance, create_fragment, __sv.safe_not_equal, { state: 0 });
	}
}

export default ICE_SHELF;
