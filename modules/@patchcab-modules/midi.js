
(function(l, r) { if (l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (window.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(window.document);
import { Faceplate, Bang, Patch, isShortcut } from '/js/core.js';

/* src/MIDI.svelte generated by Svelte v3.31.2 */

function create_default_slot(ctx) {
	let patch0;
	let t;
	let patch1;
	let current;

	patch0 = new Patch({
			props: {
				label: "gate",
				x: 60,
				y: 320,
				name: "gate-out",
				output: /*gate*/ ctx[1]
			}
		});

	patch1 = new Patch({
			props: {
				label: "note",
				x: 20,
				y: 320,
				name: "note-out",
				output: /*note*/ ctx[0]
			}
		});

	return {
		c() {
			__sv.create_component(patch0.$$.fragment);
			t = __sv.space();
			__sv.create_component(patch1.$$.fragment);
		},
		m(target, anchor) {
			__sv.mount_component(patch0, target, anchor);
			__sv.insert(target, t, anchor);
			__sv.mount_component(patch1, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const patch1_changes = {};
			if (dirty & /*note*/ 1) patch1_changes.output = /*note*/ ctx[0];
			patch1.$set(patch1_changes);
		},
		i(local) {
			if (current) return;
			__sv.transition_in(patch0.$$.fragment, local);
			__sv.transition_in(patch1.$$.fragment, local);
			current = true;
		},
		o(local) {
			__sv.transition_out(patch0.$$.fragment, local);
			__sv.transition_out(patch1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			__sv.destroy_component(patch0, detaching);
			if (detaching) __sv.detach(t);
			__sv.destroy_component(patch1, detaching);
		}
	};
}

function create_fragment(ctx) {
	let t;
	let faceplate;
	let current;
	let mounted;
	let dispose;

	faceplate = new Faceplate({
			props: {
				title: "MIDI",
				color: "var(--color-4)",
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			t = __sv.space();
			__sv.create_component(faceplate.$$.fragment);
		},
		m(target, anchor) {
			__sv.insert(target, t, anchor);
			__sv.mount_component(faceplate, target, anchor);
			current = true;

			if (!mounted) {
				dispose = [
					__sv.listen(document.body, "keydown", /*onKeyDown*/ ctx[2]),
					__sv.listen(document.body, "keyup", /*onKeyUp*/ ctx[3])
				];

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			const faceplate_changes = {};

			if (dirty & /*$$scope, note*/ 65) {
				faceplate_changes.$$scope = { dirty, ctx };
			}

			faceplate.$set(faceplate_changes);
		},
		i(local) {
			if (current) return;
			__sv.transition_in(faceplate.$$.fragment, local);
			current = true;
		},
		o(local) {
			__sv.transition_out(faceplate.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) __sv.detach(t);
			__sv.destroy_component(faceplate, detaching);
			mounted = false;
			__sv.run_all(dispose);
		}
	};
}

const keys = "qwertyuiopasdfghjklzxcvbnm";

function instance($$self, $$props, $$invalidate) {
	let down = false;
	const gate = new Bang();
	let note = new Tone.Signal(0, "audioRange");

	const remap = (num, in_min, in_max, out_min, out_max) => {
		return (num - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
	};

	const onKeyDown = e => {
		if (!isShortcut(e)) {
			return true;
		}

		const index = keys.indexOf(e.key);

		if (index !== -1) {
			let noteVal = remap(index, 0, 25, -1, 1);
			$$invalidate(0, note.value = noteVal, note);
		}

		if (!down && index > -1) {
			gate.bang(Tone.now(), true, false);
		}

		down = true;
	};

	const onKeyUp = () => {
		gate.bang(Tone.now(), false, true);
		down = false;
	};

	return [note, gate, onKeyDown, onKeyUp];
}

class MIDI extends __sv.SvelteComponent {
	constructor(options) {
		super();
		__sv.init(this, options, instance, create_fragment, __sv.safe_not_equal, {});
	}
}

export default MIDI;
