
(function(l, r) { if (l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (window.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(window.document);
import { Faceplate, onMount, Switch, Patch } from '/js/core.js';

/* src/NOISE.svelte generated by Svelte v3.31.2 */

function create_default_slot(ctx) {
	let switch0;
	let updating_value;
	let t0;
	let switch1;
	let updating_value_1;
	let t1;
	let switch2;
	let updating_value_2;
	let t2;
	let patch;
	let current;

	function switch0_value_binding(value) {
		/*switch0_value_binding*/ ctx[2].call(null, value);
	}

	let switch0_props = {
		x: 40,
		y: 170,
		label: "pink",
		set: "pink"
	};

	if (/*state*/ ctx[0].type !== void 0) {
		switch0_props.value = /*state*/ ctx[0].type;
	}

	switch0 = new Switch({ props: switch0_props });
	__sv.binding_callbacks.push(() => __sv.bind(switch0, "value", switch0_value_binding));

	function switch1_value_binding(value) {
		/*switch1_value_binding*/ ctx[3].call(null, value);
	}

	let switch1_props = {
		x: 40,
		y: 220,
		label: "white",
		set: "white"
	};

	if (/*state*/ ctx[0].type !== void 0) {
		switch1_props.value = /*state*/ ctx[0].type;
	}

	switch1 = new Switch({ props: switch1_props });
	__sv.binding_callbacks.push(() => __sv.bind(switch1, "value", switch1_value_binding));

	function switch2_value_binding(value) {
		/*switch2_value_binding*/ ctx[4].call(null, value);
	}

	let switch2_props = {
		x: 40,
		y: 270,
		label: "brown",
		set: "brown"
	};

	if (/*state*/ ctx[0].type !== void 0) {
		switch2_props.value = /*state*/ ctx[0].type;
	}

	switch2 = new Switch({ props: switch2_props });
	__sv.binding_callbacks.push(() => __sv.bind(switch2, "value", switch2_value_binding));

	patch = new Patch({
			props: {
				label: "out",
				x: 40,
				y: 320,
				name: "audio-out",
				output: /*filter*/ ctx[1]
			}
		});

	return {
		c() {
			__sv.create_component(switch0.$$.fragment);
			t0 = __sv.space();
			__sv.create_component(switch1.$$.fragment);
			t1 = __sv.space();
			__sv.create_component(switch2.$$.fragment);
			t2 = __sv.space();
			__sv.create_component(patch.$$.fragment);
		},
		m(target, anchor) {
			__sv.mount_component(switch0, target, anchor);
			__sv.insert(target, t0, anchor);
			__sv.mount_component(switch1, target, anchor);
			__sv.insert(target, t1, anchor);
			__sv.mount_component(switch2, target, anchor);
			__sv.insert(target, t2, anchor);
			__sv.mount_component(patch, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const switch0_changes = {};

			if (!updating_value && dirty & /*state*/ 1) {
				updating_value = true;
				switch0_changes.value = /*state*/ ctx[0].type;
				__sv.add_flush_callback(() => updating_value = false);
			}

			switch0.$set(switch0_changes);
			const switch1_changes = {};

			if (!updating_value_1 && dirty & /*state*/ 1) {
				updating_value_1 = true;
				switch1_changes.value = /*state*/ ctx[0].type;
				__sv.add_flush_callback(() => updating_value_1 = false);
			}

			switch1.$set(switch1_changes);
			const switch2_changes = {};

			if (!updating_value_2 && dirty & /*state*/ 1) {
				updating_value_2 = true;
				switch2_changes.value = /*state*/ ctx[0].type;
				__sv.add_flush_callback(() => updating_value_2 = false);
			}

			switch2.$set(switch2_changes);
		},
		i(local) {
			if (current) return;
			__sv.transition_in(switch0.$$.fragment, local);
			__sv.transition_in(switch1.$$.fragment, local);
			__sv.transition_in(switch2.$$.fragment, local);
			__sv.transition_in(patch.$$.fragment, local);
			current = true;
		},
		o(local) {
			__sv.transition_out(switch0.$$.fragment, local);
			__sv.transition_out(switch1.$$.fragment, local);
			__sv.transition_out(switch2.$$.fragment, local);
			__sv.transition_out(patch.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			__sv.destroy_component(switch0, detaching);
			if (detaching) __sv.detach(t0);
			__sv.destroy_component(switch1, detaching);
			if (detaching) __sv.detach(t1);
			__sv.destroy_component(switch2, detaching);
			if (detaching) __sv.detach(t2);
			__sv.destroy_component(patch, detaching);
		}
	};
}

function create_fragment(ctx) {
	let faceplate;
	let current;

	faceplate = new Faceplate({
			props: {
				title: "NOISE",
				color: "#e0e0e0",
				light: true,
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			__sv.create_component(faceplate.$$.fragment);
		},
		m(target, anchor) {
			__sv.mount_component(faceplate, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const faceplate_changes = {};

			if (dirty & /*$$scope, state*/ 65) {
				faceplate_changes.$$scope = { dirty, ctx };
			}

			faceplate.$set(faceplate_changes);
		},
		i(local) {
			if (current) return;
			__sv.transition_in(faceplate.$$.fragment, local);
			current = true;
		},
		o(local) {
			__sv.transition_out(faceplate.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			__sv.destroy_component(faceplate, detaching);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	
	let { state = { type: "pink" } } = $$props;
	const noise = new Tone.Noise(state.type).start();

	const filter = new Tone.AutoFilter({
			frequency: 440,
			baseFrequency: 200,
			octaves: 8
		}).start();

	noise.connect(filter);

	onMount(() => {
		return () => {
			noise.dispose();
		};
	});

	function switch0_value_binding(value) {
		state.type = value;
		$$invalidate(0, state);
	}

	function switch1_value_binding(value) {
		state.type = value;
		$$invalidate(0, state);
	}

	function switch2_value_binding(value) {
		state.type = value;
		$$invalidate(0, state);
	}

	$$self.$$set = $$props => {
		if ("state" in $$props) $$invalidate(0, state = $$props.state);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*state*/ 1) {
			 noise.type = state.type;
		}
	};

	return [
		state,
		filter,
		switch0_value_binding,
		switch1_value_binding,
		switch2_value_binding
	];
}

class NOISE extends __sv.SvelteComponent {
	constructor(options) {
		super();
		__sv.init(this, options, instance, create_fragment, __sv.safe_not_equal, { state: 0 });
	}
}

export default NOISE;
